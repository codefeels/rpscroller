{"version":3,"file":"RedditPostFeed-jnO0sELj.js","sources":["../../node_modules/swr/dist/infinite/index.mjs","../../src/getFeedKey.ts","../../src/RedditPostFeed.tsx"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport useSWR from '../index/index.mjs';\nimport { withMiddleware, SWRGlobalState, cache, INFINITE_PREFIX as INFINITE_PREFIX$1, createCacheHelper, isUndefined as isUndefined$1, useIsomorphicLayoutEffect, UNDEFINED as UNDEFINED$1, serialize as serialize$1, isFunction as isFunction$1 } from '../_internal/index.mjs';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\nimport { INFINITE_PREFIX } from '../_internal/constants.mjs';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst isObjectType = (value, type)=>OBJECT.prototype.toString.call(value) === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const isDate = isObjectType(arg, 'Date');\n    const isRegex = isObjectType(arg, 'RegExp');\n    const isPlainObject = isObjectType(arg, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\nconst EMPTY_PROMISE = Promise.resolve();\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = SWRGlobalState.get(cache);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX$1 + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache$1, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined$1(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined$1(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            const shouldRevalidatePage = get()._r;\n            set({\n                _r: UNDEFINED$1\n            });\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = createCacheHelper(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize$1(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined$1(pageData) || revalidateFirstPage && !i && !isUndefined$1(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined$1(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED$1\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined$1(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false,\n                        _r: options.revalidate\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true,\n                        _r: options.revalidate\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = createCacheHelper(cache$1, infiniteKey);\n            let size;\n            if (isFunction$1(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = createCacheHelper(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = serialize$1(getKey(i, previousPageData));\n                const [getCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : UNDEFINED$1;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if (isUndefined$1(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = withMiddleware(useSWR, infinite);\n\nexport { useSWRInfinite as default, infinite, unstable_serialize };\n","export function getFeedKey(url: string) {\n  return (\n    pageIndex: number,\n    previousPageData?: {\n      after?: string\n    },\n  ) => {\n    // reached the end\n    if (previousPageData && !previousPageData.after) {\n      return null\n    }\n\n    // first page, we don't have `previousPageData`\n    if (pageIndex === 0) {\n      return `${url}${url.includes('?') ? '&' : '?'}limit=25`\n    }\n\n    // add the cursor to the API endpoint\n    return `${url}${url.includes('?') ? '&' : '?'}after=${previousPageData?.after}&limit=25`\n  }\n}\n","import { useEffect, useRef } from 'react'\n\nimport useSWRInfinite from 'swr/infinite'\nimport { useIntersectionObserver } from 'usehooks-ts'\n\nimport Button from './Button'\nimport CardList from './CardList'\nimport ErrorMessage from './ErrorMessage'\nimport LoadingSpinner from './LoadingSpinner'\nimport { myfetchjson } from './fetchUtils'\nimport { getFeedKey } from './getFeedKey'\nimport { useAppStore } from './store'\nimport { modeMap } from './util'\n\nimport type { RedditResponse } from './util'\n\nexport default function RedditPostFeed() {\n  const store = useAppStore()\n  const { mode, val } = store\n  const { isIntersecting, ref } = useIntersectionObserver({\n    threshold: 0.9,\n  })\n  //\n  // useEffect(() => {\n  //   function onPopState(event: PopStateEvent) {\n  //     if (event.state) {\n  //       store.setVal((event.state as { val: string }).val)\n  //     }\n  //   }\n  //   // Handle forward/back buttons\n  //   window.addEventListener('popstate', onPopState)\n  //   return () => {\n  //     window.removeEventListener('popstate', onPopState)\n  //   }\n  // }, [store])\n\n  const isRecharging = useRef(false)\n\n  const endpoint = modeMap.get(mode)?.url\n  const url = `https://www.reddit.com/${val.startsWith('/') ? val.slice(1) : val}${endpoint ?? ''}`\n\n  const {\n    data: data2,\n    size,\n    setSize,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    error,\n    isValidating,\n    isLoading,\n  } = useSWRInfinite(getFeedKey(url), async (url: string) => {\n    const ret = (await myfetchjson(url)) as RedditResponse\n    return ret.data\n  })\n\n  const data = data2?.flatMap(d => d.children).map(d => d.data)\n\n  // these flags from https://swr.vercel.app/examples/infinite-loading\n  const isLoadingMore =\n    isLoading || (size > 0 && data2?.[size - 1] === undefined)\n  const isEmpty = (data2?.[0]?.children.length ?? 0) === 0\n  const isReachingEnd = isEmpty || (data2?.at(-1)?.children.length ?? 0) < 25\n  const isRefreshing = isValidating && data2 && data2.length === size\n\n  useEffect(() => {\n    if (\n      isIntersecting &&\n      !isRecharging.current &&\n      !isLoading &&\n      !isRefreshing &&\n      !isReachingEnd\n    ) {\n      isRecharging.current = true\n      setTimeout(() => {\n        setSize(size + 1)\n          .then(() => {\n            isRecharging.current = false\n          })\n          .catch((error: unknown) => {\n            console.error(error)\n          })\n      }, 400)\n    }\n  }, [isIntersecting, setSize, size, isReachingEnd, isRefreshing, isLoading])\n\n  return (\n    <div>\n      {isLoading ? (\n        <div className=\"flex justify-center\">\n          <LoadingSpinner />\n        </div>\n      ) : error ? (\n        <ErrorMessage error={error as unknown} />\n      ) : data ? (\n        <>\n          <CardList posts={data} />\n          <div\n            ref={ref}\n            style={{ height: 400 }}\n            className=\"flex justify-center mt-10\"\n          >\n            {isLoadingMore ? (\n              <LoadingSpinner />\n            ) : isReachingEnd ? (\n              'End of feed!'\n            ) : (\n              <div>\n                Scroll all the way down or{' '}\n                <Button\n                  onClick={() => {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    setSize(size + 1).then(() => {\n                      isRecharging.current = false\n                    })\n                  }}\n                >\n                  Click here\n                </Button>{' '}\n                to load more\n              </div>\n            )}\n          </div>\n        </>\n      ) : null}\n    </div>\n  )\n}\n"],"names":["noop","UNDEFINED","OBJECT","isUndefined","v","isFunction","table","isObjectType","value","type","counter","stableHash","arg","isDate","isRegex","isPlainObject","result","index","keys","serialize","key","args","getFirstPageKey","getKey","EMPTY_PROMISE","infinite","useSWRNext","fn","config","didMountRef","useRef","cache$1","initialSize","revalidateAll","persistSize","revalidateFirstPage","revalidateOnMount","parallel","PRELOAD","SWRGlobalState","cache","infiniteKey","INFINITE_PREFIX$1","get","set","subscribeCache","createCacheHelper","getSnapshot","useCallback","isUndefined$1","useSyncExternalStore","callback","resolvePageSize","cachedPageSize","lastPageSizeRef","useIsomorphicLayoutEffect","shouldRevalidateOnMount","swr","forceRevalidateAll","shouldRevalidatePage","UNDEFINED$1","data","pageSize","getCache","cacheData","revalidators","previousPageData","i","pageKey","pageArg","serialize$1","getSWRCache","setSWRCache","pageData","shouldFetchPage","revalidate","req","r","mutate","opts","options","shouldRevalidate","setSize","changeSize","size","isFunction$1","getInfiniteCache","useSWRInfinite","withMiddleware","useSWR","getFeedKey","url","pageIndex","RedditPostFeed","store","useAppStore","mode","val","isIntersecting","ref","useIntersectionObserver","isRecharging","endpoint","_a","modeMap","data2","error","isValidating","isLoading","myfetchjson","d","isLoadingMore","isReachingEnd","_b","_c","isRefreshing","useEffect","jsx","LoadingSpinner","ErrorMessage","jsxs","Fragment","CardList","Button"],"mappings":"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","x_google_ignoreList":[0]}