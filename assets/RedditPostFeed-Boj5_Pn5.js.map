{"version":3,"file":"RedditPostFeed-Boj5_Pn5.js","sources":["../../node_modules/swr/dist/infinite/index.mjs","../../src/postFilters.ts","../../src/LoadMoreSection.tsx","../../src/getFeedKey.ts","../../src/RedditPostFeed.tsx"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport useSWR from '../index/index.mjs';\nimport { withMiddleware, SWRGlobalState, cache, INFINITE_PREFIX as INFINITE_PREFIX$1, createCacheHelper, isUndefined as isUndefined$1, useIsomorphicLayoutEffect, UNDEFINED as UNDEFINED$1, serialize as serialize$1, isFunction as isFunction$1 } from '../_internal/index.mjs';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\nimport { INFINITE_PREFIX } from '../_internal/constants.mjs';\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\nconst isObjectType = (value, type)=>OBJECT.prototype.toString.call(value) === `[object ${type}]`;\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const isDate = isObjectType(arg, 'Date');\n    const isRegex = isObjectType(arg, 'RegExp');\n    const isPlainObject = isObjectType(arg, 'Object');\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && !isRegex) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (Array.isArray(arg)) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (isPlainObject) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n\n// We have to several type castings here because `useSWRInfinite` is a special\n// hook where `key` and return type are not like the normal `useSWR` types.\nconst EMPTY_PROMISE = Promise.resolve();\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const { cache: cache$1, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        const [, , , PRELOAD] = SWRGlobalState.get(cache);\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX$1 + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache$1, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined$1(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache$1,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache$1,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined$1(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache$1\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            const shouldRevalidatePage = get()._r;\n            set({\n                _r: UNDEFINED$1\n            });\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = createCacheHelper(cache$1, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize$1(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined$1(pageData) || revalidateFirstPage && !i && !isUndefined$1(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined$1(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && (typeof shouldRevalidatePage === 'function' ? shouldRevalidatePage(pageData, pageArg) : shouldFetchPage)) {\n                    const revalidate = async ()=>{\n                        const hasPreloadedRequest = pageKey in PRELOAD;\n                        if (!hasPreloadedRequest) {\n                            pageData = await fn(pageArg);\n                        } else {\n                            const req = PRELOAD[pageKey];\n                            // delete the preload cache key before resolving it\n                            // in case there's an error\n                            delete PRELOAD[pageKey];\n                            // get the page data from the preload cache\n                            pageData = await req;\n                        }\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED$1\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined$1(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false,\n                        _r: options.revalidate\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true,\n                        _r: options.revalidate\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1\n        ]);\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = createCacheHelper(cache$1, infiniteKey);\n            let size;\n            if (isFunction$1(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = createCacheHelper(cache$1, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = serialize$1(getKey(i, previousPageData));\n                const [getCache] = createCacheHelper(cache$1, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : UNDEFINED$1;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if (isUndefined$1(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache$1,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = withMiddleware(useSWR, infinite);\n\nexport { useSWRInfinite as default, infinite, unstable_serialize };\n","import { type Post, deduplicate } from './util'\n\nexport interface FilterStats {\n  totalPosts: number\n  commentTypeFiltered: number\n  urlTypeFiltered: number\n  gifFiltered: number\n  redGifsOnlyFiltered: number\n  noRedGifsFiltered: number\n  pinnedFiltered: number\n  blockedFiltered: number\n  remainingPosts: number\n}\n\nexport interface FilterOptions {\n  noGifs: boolean\n  blocked: string[]\n  skipPinned: boolean\n  dedupe: boolean\n  noRedGifs: boolean\n  redGifsOnly: boolean\n}\n\nexport function filterPosts(posts: Post[], options: FilterOptions): { filteredPosts: Post[], stats: FilterStats } {\n  let result = posts\n  const totalPosts = posts.length\n  const stats: FilterStats = {\n    totalPosts,\n    commentTypeFiltered: 0,\n    urlTypeFiltered: 0,\n    gifFiltered: 0,\n    redGifsOnlyFiltered: 0,\n    noRedGifsFiltered: 0,\n    pinnedFiltered: 0,\n    blockedFiltered: 0,\n    remainingPosts: 0\n  }\n\n  // Filter out comments\n  const afterCommentFilter = result.filter(post => !('comment_type' in post))\n  stats.commentTypeFiltered = result.length - afterCommentFilter.length\n  result = afterCommentFilter\n\n  // Filter by URL type\n  const afterUrlFilter = result.filter(\n    ({ url }) =>\n      url.includes('redgifs') ||\n      url.endsWith('.jpg') ||\n      url.endsWith('.webp') ||\n      url.endsWith('.jpeg') ||\n      url.endsWith('.png') ||\n      url.endsWith('.gif') ||\n      url.endsWith('.webp') ||\n      url.startsWith('https://www.reddit.com/gallery'),\n  )\n  stats.urlTypeFiltered = result.length - afterUrlFilter.length\n  result = afterUrlFilter\n\n  // Filter GIFs if needed\n  const afterGifFilter = result.filter(post =>\n    options.noGifs ? !post.url.endsWith('.gif') : true,\n  )\n  stats.gifFiltered = result.length - afterGifFilter.length\n  result = afterGifFilter\n\n  // Filter for RedGifs only if needed\n  const afterRedGifsOnlyFilter = result.filter(post =>\n    options.redGifsOnly ? post.url.includes('redgifs') : true,\n  )\n  stats.redGifsOnlyFiltered = result.length - afterRedGifsOnlyFilter.length\n  result = afterRedGifsOnlyFilter\n\n  // Filter out RedGifs if needed\n  const afterNoRedGifsFilter = result.filter(post =>\n    options.noRedGifs ? !post.url.includes('redgifs') : true,\n  )\n  stats.noRedGifsFiltered = result.length - afterNoRedGifsFilter.length\n  result = afterNoRedGifsFilter\n\n  // Filter pinned posts if needed\n  const afterPinnedFilter = result.filter(post =>\n    options.skipPinned ? !post.pinned : true,\n  )\n  stats.pinnedFiltered = result.length - afterPinnedFilter.length\n  result = afterPinnedFilter\n\n  // Filter blocked authors\n  const afterBlockedFilter = result.filter(\n    post => !options.blocked.includes(post.author),\n  )\n  stats.blockedFiltered = result.length - afterBlockedFilter.length\n  result = afterBlockedFilter\n\n  if (options.dedupe) {\n    result = deduplicate(result, post => post.url)\n  }\n\n  stats.remainingPosts = result.length\n  \n  return {\n    filteredPosts: result,\n    stats\n  }\n}\n\n","import { useEffect, useRef } from 'react'\n\nimport { useIntersectionObserver } from 'usehooks-ts'\n\nimport Button from './Button'\nimport CardList from './CardList'\nimport LoadingSpinner from './LoadingSpinner'\nimport { filterPosts } from './postFilters'\nimport { useAppStore } from './store'\n\nimport type { Post } from './util'\nimport { useIsSmallScreen } from './useIsSmallScreen'\n\nexport default function LoadMoreSection({\n  data: data2,\n  setSize,\n  size,\n  isValidating,\n  isLoading,\n}: {\n  isLoading: boolean\n  isValidating: boolean\n  data: { children: { data: Post }[] }[]\n  setSize: (\n    size: number | ((_size: number) => number),\n  ) => Promise<{ children: { data: Post }[] }[] | undefined>\n  size: number\n}) {\n  const { noGifs, blocked, skipPinned, dedupe, noRedGifs, redGifsOnly } =\n    useAppStore()\n  const small = useIsSmallScreen()\n\n  const { isIntersecting, ref } = useIntersectionObserver({\n    threshold: small ? 0.5 : 0.8,\n  })\n  const isRecharging = useRef(false)\n\n  const data = data2.flatMap(d => d.children).map(d => d.data)\n  // these flags from https://swr.vercel.app/examples/infinite-loading\n  const isLoadingMore = isLoading || (size > 0 && data2[size - 1] === undefined)\n  const isEmpty = (data2[0]?.children.length ?? 0) === 0\n  const isReachingEnd = isEmpty || (data2.at(-1)?.children.length ?? 0) < 25\n  const isRefreshing = isValidating && data2.length === size\n  useEffect(() => {\n    if (\n      isIntersecting &&\n      !isRecharging.current &&\n      !isLoading &&\n      !isRefreshing &&\n      !isReachingEnd\n    ) {\n      isRecharging.current = true\n      setTimeout(() => {\n        setSize(size + 1)\n          .then(() => {\n            isRecharging.current = false\n          })\n          .catch((error: unknown) => {\n            console.error(error)\n          })\n      }, 400)\n    }\n  }, [isIntersecting, setSize, size, isReachingEnd, isRefreshing, isLoading])\n\n  const { filteredPosts: result, stats } = filterPosts(data, {\n    noGifs,\n    blocked,\n    skipPinned,\n    dedupe,\n    noRedGifs,\n    redGifsOnly,\n  })\n  return (\n    <div>\n      <CardList posts={result} stats={stats} />\n      <div\n        ref={ref}\n        style={{ height: 400 }}\n        className=\"flex justify-center mt-10\"\n      >\n        {isLoadingMore ? (\n          <LoadingSpinner />\n        ) : isReachingEnd ? (\n          'End of feed!'\n        ) : (\n          <div>\n            (Loaded {data.length} posts {stats.commentTypeFiltered} of those\n            were comments) ... Scroll all the way down or{' '}\n            <Button\n              onClick={() => {\n                if (!isRecharging.current && !isRefreshing) {\n                  isRecharging.current = true\n                  setTimeout(() => {\n                    setSize(size + 1)\n                      .then(() => {\n                        isRecharging.current = false\n                      })\n                      .catch((error: unknown) => {\n                        console.error(error)\n                      })\n                  }, 400)\n                }\n              }}\n            >\n              Click here\n            </Button>{' '}\n            to load more\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n","export function getFeedKey(url: string) {\n  return (\n    pageIndex: number,\n    previousPageData?: {\n      after?: string\n    },\n  ) => {\n    // reached the end\n    if (previousPageData && !previousPageData.after) {\n      return null\n    }\n\n    // first page, we don't have `previousPageData`\n    if (pageIndex === 0) {\n      return `${url}${url.includes('?') ? '&' : '?'}limit=25`\n    }\n\n    // add the cursor to the API endpoint\n    return `${url}${url.includes('?') ? '&' : '?'}after=${previousPageData?.after}&limit=25`\n  }\n}\n","import useSWRInfinite from 'swr/infinite'\n\nimport ErrorMessage from './ErrorMessage'\nimport LoadMoreSection from './LoadMoreSection'\nimport LoadingSpinner from './LoadingSpinner'\nimport { myfetchjson } from './fetchUtils'\nimport { getFeedKey } from './getFeedKey'\nimport { useAppStore } from './store'\nimport { modeMap } from './util'\n\nimport type { RedditResponse } from './util'\n\nexport default function RedditPostFeed() {\n  const store = useAppStore()\n  const { mode, val } = store\n\n  const endpoint = modeMap.get(mode)?.url\n  const url = `https://www.reddit.com/${val.startsWith('/') ? val.slice(1) : val}${endpoint ?? ''}`\n\n  const {\n    data,\n    size,\n    setSize,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    error,\n    isValidating,\n    isLoading,\n  } = useSWRInfinite(getFeedKey(url), async (url: string) => {\n    const ret = await myfetchjson<RedditResponse>(url)\n    return ret.data\n  })\n\n  return (\n    <div>\n      {isLoading ? (\n        <div className=\"flex justify-center\">\n          <LoadingSpinner />\n        </div>\n      ) : error ? (\n        <ErrorMessage error={error as unknown} />\n      ) : data ? (\n        <LoadMoreSection\n          data={data}\n          setSize={setSize}\n          size={size}\n          isValidating={isValidating}\n          isLoading={isLoading}\n        />\n      ) : null}\n    </div>\n  )\n}\n"],"names":["noop","UNDEFINED","OBJECT","isUndefined","v","isFunction","table","isObjectType","value","type","counter","stableHash","arg","isDate","isRegex","isPlainObject","result","index","keys","serialize","key","args","getFirstPageKey","getKey","EMPTY_PROMISE","infinite","useSWRNext","fn","config","didMountRef","useRef","cache$1","initialSize","revalidateAll","persistSize","revalidateFirstPage","revalidateOnMount","parallel","PRELOAD","SWRGlobalState","cache","infiniteKey","INFINITE_PREFIX$1","get","set","subscribeCache","createCacheHelper","getSnapshot","useCallback","isUndefined$1","useSyncExternalStore","callback","resolvePageSize","cachedPageSize","lastPageSizeRef","useIsomorphicLayoutEffect","shouldRevalidateOnMount","swr","forceRevalidateAll","shouldRevalidatePage","UNDEFINED$1","data","pageSize","getCache","cacheData","revalidators","previousPageData","i","pageKey","pageArg","serialize$1","getSWRCache","setSWRCache","pageData","shouldFetchPage","revalidate","req","r","mutate","opts","options","shouldRevalidate","setSize","changeSize","size","isFunction$1","getInfiniteCache","useSWRInfinite","withMiddleware","useSWR","filterPosts","posts","stats","afterCommentFilter","post","afterUrlFilter","url","afterGifFilter","afterRedGifsOnlyFilter","afterNoRedGifsFilter","afterPinnedFilter","afterBlockedFilter","deduplicate","LoadMoreSection","data2","isValidating","isLoading","noGifs","blocked","skipPinned","dedupe","noRedGifs","redGifsOnly","useAppStore","small","useIsSmallScreen","isIntersecting","ref","useIntersectionObserver","isRecharging","d","isLoadingMore","isReachingEnd","_a","_b","isRefreshing","useEffect","error","jsx","CardList","LoadingSpinner","Button","getFeedKey","pageIndex","RedditPostFeed","store","mode","val","endpoint","modeMap","myfetchjson","ErrorMessage"],"mappings":"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","x_google_ignoreList":[0]}